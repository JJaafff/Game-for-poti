<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Poti Game</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>
  <style>
    body { 
      margin: 0; 
      background: #222; 
      display: flex; 
      justify-content: center; 
      align-items: center; 
      height: 100vh; 
      overflow: hidden;
      touch-action: none; /* Prevent default touch behaviors */
      -webkit-touch-callout: none; /* Disable callout on iOS */
      -webkit-user-select: none; /* Disable text selection */
      user-select: none;
    }
    canvas {
      display: block;
      max-width: 100%;
      max-height: 100%;
    }
  </style>
</head>
<body>

<script>
class GameScene extends Phaser.Scene {
  constructor() {
    super('GameScene');
    this.totalBottles = 6;
    this.gameActive = false; // Prevents movement before start
  }

  preload() {
    this.load.image('background', 'licensed-image.jpg');
  }

  create() {
    // Store game dimensions (use base game size, not scaled)
    this.gameWidth = 1200;
    this.gameHeight = 700;
    this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    
    // Get actual display size for positioning
    this.displayWidth = this.scale.displaySize.width;
    this.displayHeight = this.scale.displaySize.height;

    // 1. BACKGROUND
    const bg = this.add.image(this.gameWidth / 2, this.gameHeight / 2, 'background');
    bg.setDisplaySize(this.gameWidth, this.gameHeight);

    // 2. GENERATE TEXTURES
    this.makeBetterPlayer(); 
    this.makeBottleTextures();
    this.makeTrashCanTexture();
    this.makePlatformTextures();

    // 3. PHYSICS & FLOOR
    this.platforms = this.physics.add.staticGroup();
    const groundY = this.gameHeight - 105; // Position ground near bottom
    const groundBody = this.add.rectangle(this.gameWidth / 2, groundY, this.gameWidth, 20, 0x000000, 0);
    this.physics.add.existing(groundBody, true);
    this.platforms.add(groundBody);

    // 4. PLATFORMS - Scale positions based on screen size
    const scaleX = this.gameWidth / 1200;
    const scaleY = this.gameHeight / 700;
    const levelLayout = [
      {x: 220 * scaleX, y: 440 * scaleY, w: 150 * scaleX, c: 'plat_red'},
      {x: 450 * scaleX, y: 360 * scaleY, w: 150 * scaleX, c: 'plat_blue'},
      {x: 680 * scaleX, y: 400 * scaleY, w: 130 * scaleX, c: 'plat_yellow'},
      {x: 580 * scaleX, y: 230 * scaleY, w: 150 * scaleX, c: 'plat_green'},
      {x: 880 * scaleX, y: 300 * scaleY, w: 150 * scaleX, c: 'plat_red'},
      {x: 1080 * scaleX, y: 340 * scaleY, w: 130 * scaleX, c: 'plat_blue'}
    ];

    levelLayout.forEach(p => {
      const plat = this.platforms.create(p.x, p.y, p.c);
      plat.setDisplaySize(p.w, 35);
      plat.refreshBody();
    });

    // 5. TRASH CAN - Position relative to screen
    const trashCanX = this.gameWidth - 70 * scaleX;
    const trashCanY = groundY - 40;
    this.trashCan = this.physics.add.staticSprite(trashCanX, trashCanY, 'trashcan');
    this.trashCan.setDisplaySize(60 * scaleX, 80 * scaleY);
    this.trashCan.setDepth(5);
    
    // 6. PLAYER - Position relative to screen
    this.player = this.physics.add.sprite(100 * scaleX, (groundY - 95) * scaleY, 'player');
    this.player.setDisplaySize(50 * scaleX, 90 * scaleY);
    this.player.setCollideWorldBounds(true);
    this.player.setDepth(10);
    this.player.setBounce(0.1);

    // 7. BOTTLES
    this.bottles = this.physics.add.group();
    levelLayout.forEach(p => {
      const b = this.bottles.create(p.x, p.y - 60, 'glass');
      b.body.allowGravity = false;
    });

    // COLLIDERS
    this.physics.add.collider(this.player, this.platforms);
    this.physics.add.overlap(this.player, this.bottles, (p, b) => {
      b.disableBody(true, true);
      this.collected++;
      this.updateScore();
    }, null, this);

    // UI & INPUT
    this.cursors = this.input.keyboard.createCursorKeys();
    this.jumpKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
    this.collected = 0;
    this.deposited = 0;
    // Score text - responsive font size
    const fontSize = this.isMobile ? 18 : 26;
    this.scoreText = this.add.text(20 * scaleX, 20 * scaleY, 'ჩანთაში: 0 | შეგროვებული: 0', {
      fontSize: fontSize + 'px', fill: '#fff', stroke: '#000', strokeThickness: 5
    }).setScrollFactor(0);

    // MOBILE TOUCH CONTROLS
    this.createTouchControls();

    // INITIAL POPUP
    this.showPopup("LEVEL 1", "დონე : მარტივი\nშეაგროვე 6 ბოთლი და\n მოათავსე ნაგვის ურნაში.", "თამაშის დაწყება", () => {
      this.gameActive = true;
    });
  }

  update() {
    if (!this.gameActive) {
        this.player.setVelocityX(0);
        return;
    }

    // Check both keyboard and touch controls
    const leftPressed = this.cursors.left.isDown || this.leftButtonPressed;
    const rightPressed = this.cursors.right.isDown || this.rightButtonPressed;
    const jumpPressed = this.cursors.up.isDown || this.jumpKey.isDown || this.jumpButtonPressed;

    if (leftPressed) { 
      this.player.setVelocityX(-300); 
    } else if (rightPressed) { 
      this.player.setVelocityX(300); 
    } else { 
      this.player.setVelocityX(0); 
    }

    if (jumpPressed && this.player.body.touching.down) {
      this.player.setVelocityY(-720);
    }

    // Deposit Logic
    const dist = Phaser.Math.Distance.Between(this.player.x, this.player.y, this.trashCan.x, this.trashCan.y);
    if (dist < 80 && this.collected > 0) {
      this.deposited += this.collected;
      this.collected = 0;
      this.updateScore();
      this.trashCan.setTint(0x00ff00);
      this.time.delayedCall(200, () => this.trashCan.clearTint());

      // WIN CHECK
      if (this.deposited >= this.totalBottles) {
          this.gameActive = false;
          this.time.delayedCall(500, () => {
              this.showPopup("ყოჩაღ!", "ბუნება გასუფთავდა", "შემდეგი დონე", () => {
                  this.scene.restart(); // Future: Load Level 2 here
              });
          });
      }
    }
  }

  updateScore() {
    this.scoreText.setText(`ჩანთაში: ${this.collected} | შეგროვებული: ${this.deposited}`);
  }

  createTouchControls() {
    // Initialize button states
    this.leftButtonPressed = false;
    this.rightButtonPressed = false;
    this.jumpButtonPressed = false;

    // Button sizes - larger on mobile for easier tapping
    const btnRadius = this.isMobile ? 50 : 40;
    const jumpBtnRadius = this.isMobile ? 60 : 50;
    const btnFontSize = this.isMobile ? 40 : 32;
    const jumpFontSize = this.isMobile ? 44 : 36;

    // Button positions - bottom of screen (use base game coordinates)
    const btnY = 600; // Fixed position in game coordinates
    const leftBtnX = 80;
    const rightBtnX = 160;
    const jumpBtnX = 1100;

    // Button style
    const buttonStyle = {
      fontSize: btnFontSize + 'px',
      fill: '#ffffff',
      stroke: '#000000',
      strokeThickness: 4
    };

    // Left button
    const leftBtn = this.add.circle(leftBtnX, btnY, btnRadius, 0x43a047, 0.8)
      .setInteractive({ useHandCursor: true })
      .setDepth(50)
      .setScrollFactor(0);
    const leftText = this.add.text(leftBtnX, btnY, '←', buttonStyle)
      .setOrigin(0.5)
      .setDepth(51)
      .setScrollFactor(0);

    leftBtn.on('pointerdown', () => { this.leftButtonPressed = true; });
    leftBtn.on('pointerup', () => { this.leftButtonPressed = false; });
    leftBtn.on('pointerout', () => { this.leftButtonPressed = false; });

    // Right button
    const rightBtn = this.add.circle(rightBtnX, btnY, btnRadius, 0x43a047, 0.8)
      .setInteractive({ useHandCursor: true })
      .setDepth(50)
      .setScrollFactor(0);
    const rightText = this.add.text(rightBtnX, btnY, '→', buttonStyle)
      .setOrigin(0.5)
      .setDepth(51)
      .setScrollFactor(0);

    rightBtn.on('pointerdown', () => { this.rightButtonPressed = true; });
    rightBtn.on('pointerup', () => { this.rightButtonPressed = false; });
    rightBtn.on('pointerout', () => { this.rightButtonPressed = false; });

    // Jump button (on the right side)
    const jumpBtn = this.add.circle(jumpBtnX, btnY, jumpBtnRadius, 0xff6b35, 0.8)
      .setInteractive({ useHandCursor: true })
      .setDepth(50)
      .setScrollFactor(0);
    const jumpText = this.add.text(jumpBtnX, btnY, '↑', {
      fontSize: jumpFontSize + 'px',
      fill: '#ffffff',
      stroke: '#000000',
      strokeThickness: 4
    })
      .setOrigin(0.5)
      .setDepth(51)
      .setScrollFactor(0);

    jumpBtn.on('pointerdown', () => { 
      this.jumpButtonPressed = true;
      // Also trigger jump immediately if on ground
      if (this.gameActive && this.player.body.touching.down) {
        this.player.setVelocityY(-720);
      }
    });
    jumpBtn.on('pointerup', () => { this.jumpButtonPressed = false; });
    jumpBtn.on('pointerout', () => { this.jumpButtonPressed = false; });

    // Store references
    this.touchControls = {
      leftBtn, leftText, rightBtn, rightText, jumpBtn, jumpText
    };
  }

  // --- POPUP UI FUNCTION ---
  showPopup(titleText, descText, btnLabel, callback) {
    const centerX = this.gameWidth / 2;
    const centerY = this.gameHeight / 2;
    const isMobile = this.isMobile;
    
    // Dark Overlay - positioned at screen center
    const overlay = this.add.rectangle(centerX, centerY, this.gameWidth, this.gameHeight, 0x000000, 0.7).setDepth(99);
    
    // Container for popup elements
    const container = this.add.container(centerX, centerY).setDepth(100);

    // Responsive popup sizes
    const boxWidth = isMobile ? this.gameWidth * 0.85 : 450;
    const boxHeight = isMobile ? this.gameHeight * 0.5 : 300;
    const titleFontSize = isMobile ? 32 : 42;
    const descFontSize = isMobile ? 18 : 22;
    const btnFontSize = isMobile ? 20 : 24;
    const btnWidth = isMobile ? boxWidth * 0.7 : 220;
    const btnHeight = isMobile ? 50 : 60;

    // Background Box
    const box = this.add.rectangle(0, 0, boxWidth, boxHeight, 0xffffff, 1);
    box.setStrokeStyle(6, 0x43a047);

    // Title
    const title = this.add.text(0, isMobile ? -boxHeight * 0.3 : -100, titleText, {
      fontSize: titleFontSize + 'px', fill: '#1b5e20', fontWeight: 'bold'
    }).setOrigin(0.5);

    // Description
    const desc = this.add.text(0, isMobile ? -20 : -20, descText, {
      fontSize: descFontSize + 'px', fill: '#333', align: 'center',
      wordWrap: { width: boxWidth - 40 }
    }).setOrigin(0.5);

    // Button
    const btnBg = this.add.rectangle(0, isMobile ? boxHeight * 0.25 : 80, btnWidth, btnHeight, 0x43a047).setInteractive({ useHandCursor: true });
    const btnText = this.add.text(0, isMobile ? boxHeight * 0.25 : 80, btnLabel, { 
      fontSize: btnFontSize + 'px', fill: '#fff' 
    }).setOrigin(0.5);

    btnBg.on('pointerdown', () => {
        container.destroy();
        overlay.destroy();
        callback();
    });

    container.add([box, title, desc, btnBg, btnText]);
    
    // Store references for cleanup
    this.popupOverlay = overlay;
    this.popupContainer = container;
  }

  // --- CHARACTER DESIGN ---
  makeBetterPlayer() {
    const g = this.make.graphics({ add: false });
    
    // Legs
    g.fillStyle(0x0d47a1, 1);
    g.fillRect(15, 65, 8, 18);
    g.fillStyle(0x1565c0, 1); 
    g.fillRect(15, 65, 3, 18);
    
    g.fillStyle(0x0d47a1, 1);
    g.fillRect(27, 65, 8, 18);
    g.fillStyle(0x1565c0, 1);
    g.fillRect(27, 65, 3, 18);
    
    g.fillStyle(0x424242, 1);
    g.fillEllipse(19, 83, 10, 4); 
    g.fillEllipse(31, 83, 10, 4); 

    // Body
    g.fillStyle(0x1976d2, 1);
    g.fillRoundedRect(12, 32, 26, 32, 5);
    g.fillStyle(0x2196f3, 1);
    g.fillRoundedRect(12, 32, 8, 32, 5);
    
    // Arms
    g.fillStyle(0x1976d2, 1);
    g.fillRoundedRect(5, 35, 6, 22, 3);
    g.fillRoundedRect(39, 35, 6, 22, 3);
    
    g.fillStyle(0xffccbc, 1);
    g.fillCircle(8, 57, 4); 
    g.fillCircle(42, 57, 4); 

    // Head
    g.fillStyle(0xffccbc, 1);
    g.fillCircle(25, 16, 13);
    
    // Hair
    g.fillStyle(0x3e2723, 1);
    g.fillEllipse(25, 8, 20, 12);

    // Face
    g.fillStyle(0xffffff, 1);
    g.fillCircle(21, 15, 3.5);
    g.fillCircle(29, 15, 3.5);
    g.fillStyle(0x000000, 1);
    g.fillCircle(21, 15, 2);
    g.fillCircle(29, 15, 2);
    
    g.lineStyle(2, 0x000000);
    g.beginPath();
    g.arc(25, 21, 7, 0, Math.PI);
    g.strokePath();

    g.generateTexture('player', 50, 90);
    g.destroy();
  }

  makePlatformTextures() {
    const colors = { plat_red: 0xff4747, plat_blue: 0x47a3ff, plat_green: 0x47ff78, plat_yellow: 0xffd947 };
    Object.keys(colors).forEach(key => {
      const g = this.make.graphics({ add: false });
      g.fillStyle(colors[key]); g.fillRoundedRect(0, 0, 100, 30, 8);
      g.lineStyle(3, 0x000); g.strokeRoundedRect(0, 0, 100, 30, 8);
      g.generateTexture(key, 100, 30);
      g.destroy();
    });
  }

  makeBottleTextures() {
    const g = this.make.graphics({ add: false });
    g.fillStyle(0xb3e5fc, 0.8); g.fillRoundedRect(4, 10, 22, 40, 6);
    g.fillRoundedRect(10, 0, 10, 10, 3);
    g.fillStyle(0xffffff, 0.4); g.fillRect(8, 14, 4, 28);
    g.fillStyle(0x8d6e63, 1); g.fillRect(10, -4, 10, 4);
    g.generateTexture('glass', 30, 50);
    g.destroy();
  }

  makeTrashCanTexture() {
    const g = this.make.graphics({ add: false });
    
    // Main body with rounded corners
    g.fillStyle(0x424242, 1);
    g.fillRoundedRect(8, 20, 44, 55, 4);
    
    // Body shading/highlight
    g.fillStyle(0x616161, 1);
    g.fillRoundedRect(8, 20, 12, 55, 4);
    
    // Top rim/opening
    g.fillStyle(0x555555, 1);
    g.fillRoundedRect(5, 18, 50, 8, 3);
    
    // Lid/top cover
    g.fillStyle(0x757575, 1);
    g.fillRoundedRect(2, 12, 56, 10, 4);
    g.fillStyle(0x616161, 1);
    g.fillRoundedRect(2, 12, 56, 4, 4);
    
    // Handle on lid
    g.fillStyle(0x424242, 1);
    g.fillRoundedRect(22, 8, 12, 6, 2);
    g.fillStyle(0x333333, 1);
    g.fillRoundedRect(24, 6, 8, 4, 1);
    
    // Decorative lines/bands on body
    g.lineStyle(2, 0x616161);
    g.beginPath();
    g.moveTo(12, 40);
    g.lineTo(48, 40);
    g.strokePath();
    g.beginPath();
    g.moveTo(12, 55);
    g.lineTo(48, 55);
    g.strokePath();
    g.beginPath();
    g.moveTo(12, 50);
    g.lineTo(48, 50);
    g.strokePath();
    
    // Recycling symbol (simplified)
    g.lineStyle(2, 0x43a047);
    g.beginPath();
    g.moveTo(25, 30);
    g.lineTo(30, 35);
    g.lineTo(25, 40);
    g.strokePath();
    g.beginPath();
    g.moveTo(30, 30);
    g.lineTo(25, 35);
    g.lineTo(30, 40);
    g.strokePath();
    
    // Bottom base/shadow
    g.fillStyle(0x212121, 1);
    g.fillEllipse(30, 75, 50, 8);
    
    g.generateTexture('trashcan', 60, 80);
    g.destroy();
  }
}

const config = {
  type: Phaser.AUTO,
  width: 1200,
  height: 700,
  physics: { default: 'arcade', arcade: { gravity: { y: 1300 }, debug: false } },
  scene: GameScene,
  scale: {
    mode: Phaser.Scale.FIT,
    autoCenter: Phaser.Scale.CENTER_BOTH,
    parent: 'phaser-game',
    width: 1200,
    height: 700
  }
};
new Phaser.Game(config);
</script>

</body>
</html>
